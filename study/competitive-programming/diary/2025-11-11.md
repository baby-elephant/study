## 日付

2025-11-11

## やったこと

1:43:00

### APG4b

- [A - Sigma Cubes](https://atcoder.jp/contests/abc425/tasks/abc425_a)
  - https://atcoder.jp/contests/abc425/submissions/70868851
- [引数の配列を変化させる例](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
  - 「比較的簡単に書くことが出来ます」でこのれべるかよ😅
  - 読んだら別に難しくなかった。そして配列の参照を使ってすでに確認したかどうかを記録していく仕組みがかなり面白かった
- [EX20 - 報告書の枚数](https://atcoder.jp/contests/apg4b/tasks/APG4b_cc)
  - 着手中・・・


<details>
<summary>引数の配列を変化させる例 解答例</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;

// 正しい移動かを調べる (y, x)が移動先
bool is_valid_move(vector<string> &board, vector<vector<bool>> &checked, int x, int y) {
  int N = board.size();

  // 移動先がマス目の外である場合
  if (x <= -1 || x >= N || y <= -1 || y >= N) {
    return false;
  }
  // 移動先が壁マス
  if (board.at(y).at(x) == '#') {
    return false;
  }
  // 既に調べているマスへの移動は調べないのでfalseを返す
  if (checked.at(y).at(x)) {
    return false;
  }

  // それ以外なら正しい移動
  return true;
}

// (y, x)にいる状態からゴールに到達できるか
// board: マス目の種類
// checked: そのマスを既に調べたかを持つ二次元配列
bool reachable(vector<string> &board, vector<vector<bool>> &checked, int x, int y) {
  int N = board.size();

  // ベースケース
  if (x == N - 1 && y == N - 1) {
    // ゴールにいる状態
    return true;
  }

  // 再帰ステップ

  checked.at(y).at(x) = true;  // 既に調べているという状態に変えておく

  // 「上」「右」「下」「左」のいずれかの移動でゴールに到達できるか？
  bool result = false;

  // 上へ移動したマスからゴールに到達できるか？
  if (is_valid_move(board, checked, x, y - 1) && reachable(board, checked, x, y - 1)) {
    result = true;
  }
  // 右へ移動したマスからゴールに到達できるか？
  if (is_valid_move(board, checked, x + 1, y) && reachable(board, checked, x + 1, y)) {
    result = true;
  }
  // 下へ移動したマスからゴールに到達できるか？
  if (is_valid_move(board, checked, x, y + 1) && reachable(board, checked, x, y + 1)) {
    result = true;
  }
  // 左へ移動したマスからゴールに到達できるか？
  if (is_valid_move(board, checked, x - 1, y) && reachable(board, checked, x - 1, y)) {
    result = true;
  }

  return result;
}

int main() {
  int N;
  cin >> N;
  // マス目の状態を受け取る
  vector<string> board(N);
  for (int i = 0; i < N; i++) {
    cin >> board.at(i);
  }

  // 既にそのマスを調べたかを保持する二次元配列
  vector<vector<bool>> checked(N, vector<bool>(N, false));  // false(まだ調べていない)で初期化しておく

  // (0, 0) からゴールまで到達できるか？
  if (reachable(board, checked, 0, 0)) {
    cout << "Yes" << endl;
  }
    else {
    cout << "No" << endl;
  }
}

```

</details>


## 感想

[GraphxGraph](https://hello-world-494ec.firebaseapp.com/)を軽く使ってみたけどわかりやすくていいな


## ToDo
- さすがにformatterくらいは欲しくなってきた・・・\
　⇒VSCodeの拡張機能を入れてみた。様子見・・・
- メディバンペイント
- GraphxGraph
- C++の環境準備をしておく？

## AtCoder Problems
そういえば、現段階での情報を載せておいた方がいい気がしてきたので載せよう\
2022/11/05~2022/12/31までに6問だけやっていたらしい
![コンテスト実績](../img/contest.png)  
![atcoderの進捗表（kenkoooo.com）](../img/kenkoooo.com_atcoder.png)

## 金言
「茶色になるために一番重要なのは、C問題をひたすら解いて理解することだぜ、私はほとんどの問題を自力でACすることができず解説放送を見てようやっとACできた問題が7割ほどだったから、自分に才能がないと諦めないようにすることが大事だな。私は灰色の頃コンテストで負けるたびに何度も思っていたぜ」

## やること
1. [APG4b](https://atcoder.jp/contests/APG4b)
  - 第２章まで（setやmapはB問題を解く中で身につく）
  - 練習問題も解く
2. [AtCoder に登録したら次にやること ～ これだけ解けば十分闘える！過去問精選 10 問 ～](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
  - 動画主はどれも自力で解けずすべてけんちょんさんの解説を見たらしいので、解けなくても気落ちしない
  - C問題も載っているので理解するのは難しく解けなくて当たり前適当にやりましょう
  - 解説のコードで何が起きているかを一通り理解できるまで粘る
  - これでAtCoderで問題を解くときの一通りの流れがわかる
3. [A,B問題の精進](https://kenkoooo.com/atcoder/#/table/)
  - A問題を20問解いてからB問題に進む
  - vectorの使い方(1,2次元)
  - setやmapの使い方
  - 四近傍を配列荷物
  - グリッドやグラフの基礎（動画主も、グリッドとか何それ？と思っていたらしい）
  - 全探索の基礎
  - C問題以降でも毎回使うような基礎的な内容が学べる
  - 公式の解説放送がものすごくわかりやすいのでお勧めらしい
  - B問題をある程度解けるようになったらC問題に行くのがいいと思うらしい
  - 動画主は340~154までの約200問のB問題を解いたらしい・・・あくまで自分でやってみて満足すればCに進めばいいとのこと
  - ABC212以降から出題の仕方が変わっているため、それ以降の問題を解くのがお勧めらしい
4. [C問題の精進](https://kenkoooo.com/atcoder/#/table/)をひたすら解く
  - 灰色から茶色になろうとするとC問題を解く必要が出てくる
  - 茶色から緑色になろうとするタイミングではC問題のACは必須になる
  - C問題を100問くらい解き終わる頃には茶色になったらしい
5. [EDPC](https://atcoder.jp/contests/dp/tasks)
  - A~Eまで行ったらしい
  - ただ、EDPCの問題を解いたからと言って本番でDPの問題を解けたことはなかったらしい
  - 緑色になってから基礎的な内容を完璧に理解できたとのこと
  - ひとまず茶色になるまではDPを理解出来なくてもよさそうとのこと

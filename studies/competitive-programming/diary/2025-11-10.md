## やったこと

0:59:00

### APG4b

- [例題 報告書の伝達時間](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
  - 再帰処理をイメージ出来る速度が少し早くなったのを感じた。がまだまだだ。。。ACできなかったし。。。
- [A - OS Versions](https://atcoder.jp/contests/abc426/tasks/abc426_a)
  - https://atcoder.jp/contests/abc426/submissions/70850732
- [引数の配列を変化させる例](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
  - 途中。これが理解出来たら大きな一歩に思う

<details>
<summary>例題 報告書の伝達時間</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#include <bits/stdc++.h>
using namespace std;

#define PRINT_2D_DEBUG(vec) do { \
    cout << #vec << " = [" << endl; \
    for (size_t i = 0; i < (vec).size(); ++i) { \
        cout << "  [" << i << "]: "; \
        for (size_t j = 0; j < (vec)[i].size(); ++j) { \
            cout << (vec)[i][j] << (j + 1 == (vec)[i].size() ? '\n' : ' '); \
        } \
        if((vec)[i].size() == 0) cout << endl;\
    } \
    cout << "]" << endl; \
} while(0)

/**
 * 例題 報告書の伝達時間
 * あるタイミングで一斉に報告書の伝達を開始したときに、
 * トップの組織の元に全ての組織の報告書が揃う時刻（伝達を始めてから何分後か）を求めてください。 
 * 問題の理解
 * １．トップの組織までに届くのが最も時間がかかるのは,最下層の組織からの伝達なので,
 * 　　最下層がトップから何個目の組織かがわかればいい
 * 
 */
// 00:09:00~1:05:00 ギブアップ答えを見よう

// x番の組織について、子組織からの報告書が揃った時刻を返す
// childrenは組織の関係を表す2次元配列(参照渡し)
// 追記：children = { 0:{1, 2}, 1:{3, 4}, 2:{}, 3:{}, 4:{5}, 5:{} }
int complete_time(vector<vector<int>> &children, int x) {
  // (ここに追記して再帰関数を実装する)
  /**
   * 進み方
   * 0 -> 1 -> 3
   * 0 -> 1 -> 4 -> 5
   * 0 -> 2
   * childrenの要素(数字)をキーとして、他のchildrenの要素を取得して、・・・というのを繰り返す
   * 　⇒そして、その繰り返しのたびにカウントしていく
   * Step１まずはその順序で再帰する仕組みを作る
   * Step2合計を出す仕組みを作る
   */
  // Step1
  // cout << "x: " << x << endl;
  // cout << "children.at(x).size(): " << children.at(x).size() << endl;
  // for (int i = 0; i < (int)(children.at(x).size()); i++) {
  //   cout << "i: " << i << endl;
  //   complete_time(children, children.at(x).at(i));
  // }
  // return 0; // なるほど、何もreturnしないと、再帰が回らないで終了してしまうのか、だからx=3で止まってしまっていたのか
  // とりあえずStep１は完了！
  
  // Step2
  // int counter  = 0;
  // cout << "x: " << x << endl;
  // for (int i = 0; i < (int)((children.at(x)).size()); i++) {
  //   cout << "i: " << i << endl;
  //   counter += complete_time(children, children.at(x).at(i));
  //   cout << endl;
  //   counter++;
  //   cout << counter << endl; 
  // }

  // return counter;

  // 答えを見た
  // やはりスタックというイメージでいい。
  // うん、処理の流れをイメージするのは以前より早くなってきている感触はある
  int max_counter  = 0;
  // cout << "x: " << x << endl;
  for (int i = 0; i < (int)((children.at(x)).size()); i++) {
    // cout << "i: " << i << endl;
    int counter = complete_time(children, children.at(x).at(i)) + 1;
    // cout << endl;
    max_counter = max(max_counter, counter);
  }

  return max_counter;



}

// これ以降の行は変更しなくてよい

/**
 * 入力例
 * 6
 * 0 0 1 1 4
 */

int main() {
  int N;
  cin >> N;

  vector<int> p(N);  // 各組織の親組織を示す配列
  p.at(0) = -1;  // 0番組織の親組織は存在しないので-1を入れておく
  for (int i = 1; i < N; i++) {
    cin >> p.at(i);
  }
  // 追記：p = {-1, 0, 0, 1, 1, 4}

  // 組織の関係から2次元配列を作る(理解しなくてもよい)
  vector<vector<int>> children(N);  // ある組織の子組織の番号一覧  // N×0の二次元配列
  for (int i = 1; i < N; i++) {
    // cout << "i: " << i << endl;
    int parent = p.at(i);  // i番の親組織の番号
    children.at(parent).push_back(i);  // parentの子組織一覧にi番を追加
  }
  // 追記: children = {{1, 2}, {3, 4}, {}, {}, {5}, {}}
  // PRINT_2D_DEBUG(children);


  // 0番の組織の元に報告書が揃う時刻を求める
  cout << complete_time(children, 0) << endl;
}

```

</details>


## 感想

異様に眠いので寝るzzz\



## ToDo
- さすがにformatterくらいは欲しくなってきた・・・\
　⇒VSCodeの拡張機能を入れてみた。様子見・・・
- メディバンペイント
- GraphxGraph
- C++の環境準備をしておく？

## AtCoder Problems
そういえば、現段階での情報を載せておいた方がいい気がしてきたので載せよう\
2022/11/05~2022/12/31までに6問だけやっていたらしい
![コンテスト実績](../img/contest.png)  
![atcoderの進捗表（kenkoooo.com）](../img/kenkoooo.com_atcoder.png)

## 金言
「茶色になるために一番重要なのは、C問題をひたすら解いて理解することだぜ、私はほとんどの問題を自力でACすることができず解説放送を見てようやっとACできた問題が7割ほどだったから、自分に才能がないと諦めないようにすることが大事だな。私は灰色の頃コンテストで負けるたびに何度も思っていたぜ」

## やること
1. [APG4b](https://atcoder.jp/contests/APG4b)
  - 第２章まで（setやmapはB問題を解く中で身につく）
  - 練習問題も解く
2. [AtCoder に登録したら次にやること ～ これだけ解けば十分闘える！過去問精選 10 問 ～](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
  - 動画主はどれも自力で解けずすべてけんちょんさんの解説を見たらしいので、解けなくても気落ちしない
  - C問題も載っているので理解するのは難しく解けなくて当たり前適当にやりましょう
  - 解説のコードで何が起きているかを一通り理解できるまで粘る
  - これでAtCoderで問題を解くときの一通りの流れがわかる
3. [A,B問題の精進](https://kenkoooo.com/atcoder/#/table/)
  - A問題を20問解いてからB問題に進む
  - vectorの使い方(1,2次元)
  - setやmapの使い方
  - 四近傍を配列荷物
  - グリッドやグラフの基礎（動画主も、グリッドとか何それ？と思っていたらしい）
  - 全探索の基礎
  - C問題以降でも毎回使うような基礎的な内容が学べる
  - 公式の解説放送がものすごくわかりやすいのでお勧めらしい
  - B問題をある程度解けるようになったらC問題に行くのがいいと思うらしい
  - 動画主は340~154までの約200問のB問題を解いたらしい・・・あくまで自分でやってみて満足すればCに進めばいいとのこと
  - ABC212以降から出題の仕方が変わっているため、それ以降の問題を解くのがお勧めらしい
4. [C問題の精進](https://kenkoooo.com/atcoder/#/table/)をひたすら解く
  - 灰色から茶色になろうとするとC問題を解く必要が出てくる
  - 茶色から緑色になろうとするタイミングではC問題のACは必須になる
  - C問題を100問くらい解き終わる頃には茶色になったらしい
5. [EDPC](https://atcoder.jp/contests/dp/tasks)
  - A~Eまで行ったらしい
  - ただ、EDPCの問題を解いたからと言って本番でDPの問題を解けたことはなかったらしい
  - 緑色になってから基礎的な内容を完璧に理解できたとのこと
  - ひとまず茶色になるまではDPを理解出来なくてもよさそうとのこと

## やったこと

03:30:00
### APG4b

- [Nが素数であるかを判定する関数 is_prime](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
- [配列の操作 reverse_array](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
- [A - ABC -> AC](https://atcoder.jp/contests/abc427/tasks/abc427_a)
  - https://atcoder.jp/contests/abc427/submissions/70834282
- [例題 報告書の伝達時間](https://atcoder.jp/contests/apg4b/tasks/APG4b_v)
  - 途中（1時間考えたけど答えにたどり着かなかったのでヒントを見たところ

<details>
<summary>Nが素数であるかを判定する関数 is_prime</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)

// Nが素数であるかを判定する関数 is_prime

  /**
  * 返り値：素数ならtrue,素数じゃないならfalseを返す
  */
bool is_prime_num(int num,int N) {
  // cout << "num: " << num << endl;
  // cout << "N: " << N << endl;
  // cout << "(N % num != 0): " << (N % num != 0) << endl;
  // ベースケース
  // 割られる数字が,数字Nと一緒だったら,絶対に割れる(判定できない)ので素数として返す
  if(num == N) {
    return true;
  }

  // 再帰ステップ：条件式の最初に記載することで、Nが素数じゃないと分かった段階で再帰を抜ける
  bool result = N % num != 0 && is_prime_num(num+1, N);
  // cout << "result: " << result << endl;
  return result; // trueは素数,falseは素数じゃない
}

bool is_prime(int N) {

  // 戻り値がfalseだったら,素数じゃない
  return is_prime_num(1+1, N);
}

// 0:01:00
int main() {
  /**
   * 問題の理解
   * ・まず素数とは？1とその数以外で割れない数
   * ・3で考えてみる
   * 　・3が3で割れるか？⇒割れる
   * 　・3が2で割れるか？⇒割れない
   * 　・3が1で割れるか？⇒割れる
   * 　　⇒1とその数でしか割れないので、3は素数
   * ・4で考えてみる
   * 　・4が4で割れるか？⇒割れる
   * 　・4が3で割れるか？⇒割れない
   * 　・4が2で割れるか？⇒割れる
   * 　・4が1で割れるか？⇒割れる
   * 　　⇒2でも割れるので、4は素数じゃない
   * 1 ~ Ｎで、1とＮについては割れるかを見る必要がない（確実に割れるので）
   * なので、範囲は(2 ~ N -1)となる
   * (a%N!=0), ((a+1)%N!=0), ~~~, ((N-2)%N!=0), ((N-1)%N!=0)
   * 日本語で言うと,下記を実装すればいい
   * Nが素数であるとき = aがNで割り切れないとき　&&　(a+1以降N-1以下)がNで割り切れないとき
   * 上の日本語で表せるので,再帰関数を使うことを考える(もともとそういう問題ではあるけど実践を意識してね)
   * 0:16:00
   * 再帰関数を考える
   * ・引数：割られる数字, 数字N
   * ・返り値：「割り切れないとき」なので(数字%N!=0)の結果を返せばいい：bool
   * ・処理内容：割られる数字をNで割って、余りがなければfalse(素数じゃない)を返す。余りがあればtrue(素数だよ)を返す
   * 0:21:00
   * ベースケースを考える
   * ・戻り値がfalseだったら,処理を終了
   * ・割られる数字が,数字Nと一緒だったら、素数じゃないとして処理を終了
   * 0:23:00
   */
  
   // 実装開始00:23:30
   int N;
   cin >> N;
   if(is_prime(N)) {
     cout << N << "は素数です" << endl;
   }else {
    cout << N << "は素数じゃないです" << endl;
   }
   // 00:44:46
   // 00:55:13  // num % Nとしていて、それに気が付くのに10分ぐらいかかってしまった
  
  // 解説を見て追記
  cout << is_prime(1) << endl;  // 0
  cout << is_prime(2) << endl;  // 1
  cout << is_prime(12) << endl; // 0
  cout << is_prime(13) << endl; // 1
  cout << is_prime(57) << endl; // 0
}

```

</details>

<details>
<summary>配列の操作 reverse_array</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)

/**
 * 配列の操作 reverse_array
 * 参照渡しで与えられた配列を逆順に並べ替えた結果を返す関数`reverse_array`
 */ 
// 1:15:00
/**
 * 問題の理解
 * １．reverse_arrayという関数を作るらしい
 * ２．引数には配列の参照が入るらしい。
 * 配列を逆順にするとはどういうことか考える
 * 例：vector<int> nums = {1,2,3};
 * for文を使うなら, [(nums.size()-1)-i]で、後ろのがとれるから、それを新しい配列に入れていく感じで作れるのは思い浮かぶ
 * 今回は参照が渡ってくるということは、その参照先の配列を書き換える形で実装できるということなのかな。
 * あぁてか、方針としてはnums[0]とnums[nums.size()-1]を入れ替えていけばいいんだな。
 * 例/パターンを考えよう
 * サイズが偶数個のとき：[1,2,3,4]
 * 　・indexが0のとき, 0と3を入れ替える
 * 　・indexが1のとき, 1と2を入れ替える
 * 　　⇒完了！
 * サイズが奇数個のとき：[1,2,3]
 * 　・indexが0のとき, 0と2を入れ替える
 * 　・indexが1のとき, 中間なので入れ替えない
 * ベースケースは？
 * 　・偶数個のとき, 前半の処理が終わったとき
 * 　・奇数個のとき, 真ん中の要素に来た時
 * 関数を考える
 * 引数: 配列の参照
 * 返り値: 逆になった配列（参照先を変化させるのでとくにreturnする必要もない）
 * 処理: 入れ替えていく
 * 再帰ステップ
 * 　・入れ替えていく、後ろのindexは[(nums.size()-1)-i]で取れる
 * 1:34:00
 */

 /**
  * この再帰関数の中で入れ替えていく
  * 内側からStep-by-stepで入れ替わっていくイメージ
  */
 void reverse_array_start_end(vector<int> &array, int start, int end) {
  if(start >= end) return; 

  int start_int = array.at(start);
  array.at(start) = array.at(end);
  array.at(end) = start_int;
  reverse_array_start_end(array, (start+1), (end-1));

 }

 void reverse_array(vector<int> &array ) {
  // 偶数個か奇数個かを判定（2の剰余で出せる）
  // bool is_odd = array.size() % 2; // 0なら偶数, 1なら奇数
  /**
   * あぁ違うか、start, endがイコールになるかstart > endになったタイミングで、reverseは完了しているんだな
   * なので, start < endのとき入替処理を続行する
   * というかとなると、start, endを引数に受け取る補助関数が必要だな！
   */
  reverse_array_start_end(array, 0, (array.size()-1));
 }
 

int main() {
  vector<int> a = {1, 2, 3, 4, 5};
  // vector<int> b = reverse_array(a);
  reverse_array(a);
  // for (int i = 0; i < b.size(); i++) {
  //   cout << b.at(i) << endl;
  for (int i = 0; i < a.size(); i++) {
    cout << a.at(i) << endl;
  }
  
  // 偶数もテスト
  vector<int> aa = {1, 2, 3, 4};
  reverse_array(aa);
  for (int i = 0; i < aa.size(); i++) {
    cout << aa.at(i) << endl;
  }
  
  // 1:47:30

}

```

</details>

## 感想

APG4bに時間を掛けすぎな気もするけれど、こういう基礎的なところをないがしろにして進めてろくな目に合ったことが人生で1度もないので、掛けすぎなくらい時間を掛けていく。別に掛けてやろうと思っているわけではないけどちゃんと理解したい。\
基礎をおろそかにして先に進んでも自分の性格上また一から基礎を学ぼう！と振り返るときの心理的ハードルが高すぎるというのを感じる

難しいという意見がネット見れて一安心した。気にする必要はないのだけども。

## ToDo
- さすがにformatterくらいは欲しくなってきた・・・\
　⇒VSCodeの拡張機能を入れてみた。様子見・・・
- メディバンペイント
- GraphxGraph
- C++の環境準備をしておく？

## AtCoder Problems
そういえば、現段階での情報を載せておいた方がいい気がしてきたので載せよう\
2022/11/05~2022/12/31までに6問だけやっていたらしい
![コンテスト実績](../img/contest.png)  
![atcoderの進捗表（kenkoooo.com）](../img/kenkoooo.com_atcoder.png)

## 金言
「茶色になるために一番重要なのは、C問題をひたすら解いて理解することだぜ、私はほとんどの問題を自力でACすることができず解説放送を見てようやっとACできた問題が7割ほどだったから、自分に才能がないと諦めないようにすることが大事だな。私は灰色の頃コンテストで負けるたびに何度も思っていたぜ」

## やること
1. [APG4b](https://atcoder.jp/contests/APG4b)
  - 第２章まで（setやmapはB問題を解く中で身につく）
  - 練習問題も解く
2. [AtCoder に登録したら次にやること ～ これだけ解けば十分闘える！過去問精選 10 問 ～](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
  - 動画主はどれも自力で解けずすべてけんちょんさんの解説を見たらしいので、解けなくても気落ちしない
  - C問題も載っているので理解するのは難しく解けなくて当たり前適当にやりましょう
  - 解説のコードで何が起きているかを一通り理解できるまで粘る
  - これでAtCoderで問題を解くときの一通りの流れがわかる
3. [A,B問題の精進](https://kenkoooo.com/atcoder/#/table/)
  - A問題を20問解いてからB問題に進む
  - vectorの使い方(1,2次元)
  - setやmapの使い方
  - 四近傍を配列荷物
  - グリッドやグラフの基礎（動画主も、グリッドとか何それ？と思っていたらしい）
  - 全探索の基礎
  - C問題以降でも毎回使うような基礎的な内容が学べる
  - 公式の解説放送がものすごくわかりやすいのでお勧めらしい
  - B問題をある程度解けるようになったらC問題に行くのがいいと思うらしい
  - 動画主は340~154までの約200問のB問題を解いたらしい・・・あくまで自分でやってみて満足すればCに進めばいいとのこと
  - ABC212以降から出題の仕方が変わっているため、それ以降の問題を解くのがお勧めらしい
4. [C問題の精進](https://kenkoooo.com/atcoder/#/table/)をひたすら解く
  - 灰色から茶色になろうとするとC問題を解く必要が出てくる
  - 茶色から緑色になろうとするタイミングではC問題のACは必須になる
  - C問題を100問くらい解き終わる頃には茶色になったらしい
5. [EDPC](https://atcoder.jp/contests/dp/tasks)
  - A~Eまで行ったらしい
  - ただ、EDPCの問題を解いたからと言って本番でDPの問題を解けたことはなかったらしい
  - 緑色になってから基礎的な内容を完璧に理解できたとのこと
  - ひとまず茶色になるまではDPを理解出来なくてもよさそうとのこと
